Focus Questions

1. What is your full name?
Rubens Sequeiros de Vascocnellos Neto

2. Any repositories you wish to share with us? 
No. Unfortunately, I don't own the projects that I've participated in recently.

General Questions

1. Name some tools and/or techniques that you personally find to be the most helpful surrounding development.
There are lots of tools and techniques, but I'd like to highlight the ones I've used the most
- Version Controls, specially Git
- Containers, specially Docker (here I could also add some container orchestrators like Kubernetes, ECS, etc, depending on the requirements)
- CI/CD tools. There are lots of good CI/CD tools like Gitlab pipelines, Github actions, Bitbucket pipelines, etc (they're all very similar). There's also Jenkins that I had the opportunity to use a lot in different situations, but I consider the other options a better fit for modern applications
- Testing tools, like Jest, JUnit, etc (depending on the language)
- Cache (Redis, Memcached, etc)
- Message brokers (queues and topic)
- Also there are lots of other components that could be used depending on the architecture, such as search engines (i.e. elasticsearch), function as a service (i.e. lambdas), Storages (i.e. S3)

2. Name some tools and/or techniques that you personally find to be the most helpful surrounding code maintenance.
- Testing tools, as mentioned before, because maintaining software without tests is painful and very error prone
- Static analysis tools like SonarQube, ESLint, etc
- Pull requests and code reviews

3. Explain your familiarity with automation infrastructures. The questions below are to help give a guideline, please feel free to be as detailed as you please. 
a. How did you deploy and execute your test suites? 
I use CI/CD tools, mainly Gitlab, to execute my test suites. Depending on the type of test, these test suites may depend on other tools. For example, if I want to run an integration test suite, I'll probably need to run mocked or containerized components such as queues, databases, storages, etc. I usually run the integration test environment using a docker-compose file
To deploy my application, considering that all my static analysis and test suites have passed, I mainly use shell scripts. These shell scripts may vary depending on the application that's being deployed. For example, if I'm deploying standalone applications on virtual machines, I can implement a ssh script to copy the artifact and restart the application. If the application is deployed on Kubernetes for example, I use helm to upgrade the service. There's also some tools specialized in deploying like AWS' CodeDeploy

b. How did you target different devices? 
Honestly, the most part of the tests I have written didn't relly on different devices because they were all inside docker containers. But if I wanted to run the test suites on different devices, I'd create different runners on the CI/CD tool

c. How did you handle scalability? 
I handle scalability using container orchestrators - specially Kubernetes - to auto scale the services, balance the load between them, etc
But Kubernetes itself is not enough to achieve scalability, the application must be built using some techniques like caching strategies, queues and topics for async communication
Also, to achieve scalability, it's recommended that the application is broken down into smaller pieces, so you scale only the piece that needs to be scaled

d. How did you report test results?
I use reports generated by Jest and JUnit to report test results and code coverage. And I also configure alerts on the CI/CD tool in case of failures

4. What testing frameworks are you familiar with for system level/desktop applications? 
Jest and JUnit are the testing frameworks I'm most familiarized. I don't know any framework specialized in testing desktop applications, but depending on what you want to test, tools like JUnit, Pytest, etc, can handle it

5. What testing frameworks are you familiar with for browser applications? 
Cypress and Selenium for acceptance tests. 
Other frameworks like Jest, Karma and Jasmine can help testing a frontend application

6. What tools are you familiar with for Performance, Load and Stress testing? 
JMeter and K6

7. Tell us about a project your worked on that you found to be interesting or unusual.
A online assessment product with remote supervision. While candidates take their exam, supervisors watch them in realtime. The application streams the screen, webcam and audio of the candidates. It also records all the streaming process to be reviewed later
We used Amazon Chime to handle the streaming part and S3 to store the recordings
Also, we used Electron to build a desktop version of the product. By doing this, we could block some features on the candidate's OS, like screen shots, screen recordings, two monitors, communication apps like Skype, Slack, etc.

Technical Questions

1. When would you use multithreading vs multiprocessing? 
I would use both to run multiple tasks in paralel, but multithreading tasks share the same resources (memory, cpu, etc) while multiprocessing doesn't.
Multiprocessing tasks could be assigned to different CPU cores and have the performance improved because of that

2. Describe the differences between Unit Tests, Functional Tests, and Integration Tests?
	i. Do you have a preference and why? 
- Unit tests validate the logic of individual components. Mocks can be used to avoid integrations with other components. Unit tests are cheaper and faster than the others.
- Integration tests validate the integration between components. Example: integration between the aplication and queues, databases, etc. Some level of environment setup is required here (I usually use docker-compose for that). They are not as cheap as unit tests, but they are cheaper than functional tests.
- Functional tests validate how the application is behaving in real world. To automate this kind of test, a rich environment must be setup. It could be using docker compose or even using an existing environment dedicated to functional tests
I can't say I have a preference because they have different purposes. Defining a test strategy is very important. I had the opportunity to work in a project where most part of the tests were integration tests. Because of that, the test suite took almost an hour to execute and most of the test cases could be Unit Tests

3. What are the some of the pros and cons of object-oriented programming vs functional programming? 
OOP is easier to understand as they are very close to real world definitions. It's also easier to reuse code since you can use inheritance
OOP could be harder to test depending on the language because of the private and static methods (difficult to mock). Also, due to its mutability, it can have side effects on the code
FP is easier to test since they work with immutable functions. Also, it means they are less likely to have bugs because the functions have more predictable results
FP is harder to understand in my opinion

4. What security concerns have you come across in the past and how have you addressed them?
- Enforcing authorization in the application: Some endpoints validated if the access token was valid and if the user had the permission to these endpoints. However, they didn't validate if the user had access to the resource he was trying to manipulate. I fixed it by implementing validations on each endpoint as it could not be handled generically
- Changing md5 encryption to a stronger algorithm (SHA-256)
- Preventing XSS atacks on the client side, validating the inputs in a common interceptor
- Using Secure Headers as suggested by OWASP
- Masking sensitive fields to prevent passwords to be logged on the APM tool

Small Programming Challenges

1. Using a known programming language write a small program to: 
a. Query the OS for the OS Patches that are currently installed on the system. 
	i. For example, on windows: Windows Update Settings -> View Update History
	iii. [Optional] Add a function to report if Automatic Updates are enabled or disabled for the device.

b. How would you consider validating the above program returns all installed patches on the system from an automation perspective? 
	i. What automation framework(s) you would consider utiltizing? 
I would create a virtual machine or a Docker image with a known set of patches. Then I would run the acceptance tests inside this VM or container. Note that the tests I have created are unit tests and they do not depend on the OS or installed patches. Only acceptance tests (which I have not created) have to be run inside this VM/container.

c. Let's say your program was written to be cross platform, how would you design an infrastructure for deploying your program and executing the test case(s) across multiple Windows, Linux and Mac devices?
	i. After a reboot, a system may show different patches as installed, would this cause complications with your validation? If so, what alternatives do you see available?
As mentioned before, I would create a docker image or VM with a pre-defined list of patches, which means it won't impact the automation after rebooting because the test environment will always be the same
About deploying and executing test suites according to the platform, I'd create different steps in the CI/CD pipeline, for example:
- Unit tests // mocks the command line executions, therefore it doesnt rely on the platform
- Acceptance tests (Windows) // runs inside a windows instance and don't use mocks for the command line
- Acceptance tests (Linux) // runs inside a linux instance and don't use mocks for the command line
- Acceptance tests (Mac) // runs inside a macos instance and don't use mocks for the command line
- Build (Windows)
- Build (Linux)
- Build (Max)
